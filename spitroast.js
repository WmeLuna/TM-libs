// @require      https://raw.githubusercontent.com/WmeLuna/TM-libs/main/spitroast.js
// I take no credit for this, i only modified it to be used with tampermonkey
var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__hasOwnProp=Object.prototype.hasOwnProperty,__export=(e,t)=>{for(var o in t)__defProp(e,o,{get:t[o],enumerable:!0})},__copyProps=(e,t,o,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of __getOwnPropNames(t))__hasOwnProp.call(e,c)||c===o||__defProp(e,c,{get:()=>t[c],enumerable:!(r=__getOwnPropDesc(t,c))||r.enumerable});return e},__toCommonJS=e=>__copyProps(__defProp({},"__esModule",{value:!0}),e),src_exports={};__export(src_exports,{after:()=>after,before:()=>before,instead:()=>instead,unpatchAll:()=>unpatchAll}),window.after = after;window.before = before;window.instead = instead;window.unpatchAll = unpatchAll;var patchTypes=["a","b","i"],patchedObjects=new Map;function hook_default(e,t,o,r,c){const n=patchedObjects.get(t)?.[e];if(!n)return c?Reflect.construct(t[e],o,r):t[e].apply(r,o);for(const e of n.b.values()){const t=e.call(r,o);Array.isArray(t)&&(o=t)}let a=[...n.i.values()].reduce(((e,t)=>(...o)=>t.call(r,o,e)),((...e)=>c?Reflect.construct(n.o,e,r):n.o.apply(r,e)))(...o);for(const e of n.a.values())a=e.call(r,o,a)??a;return a}function unpatch(e,t,o,r){const c=patchedObjects.get(e),n=c?.[t];if(!n?.[r].has(o))return!1;if(n[r].delete(o),patchTypes.every((e=>0===n[e].size))){Reflect.defineProperty(e,t,{value:n.o,writable:!0,configurable:!0})||(e[t]=n.o),delete c[t]}return 0==Object.keys(c).length&&patchedObjects.delete(e),!0}function unpatchAll(){for(const[e,t]of patchedObjects.entries())for(const o in t)for(const r of patchTypes)for(const c of t[o]?.[r].keys()??[])unpatch(e,o,c,r)}var getPatchFunc_default=e=>(t,o,r,c=!1)=>{if("function"!=typeof o[t])throw new Error(`${t} is not a function in ${o.constructor.name}`);patchedObjects.has(o)||patchedObjects.set(o,{});const n=patchedObjects.get(o);if(!n[t]){const e=o[t];n[t]={o:e,b:new Map,i:new Map,a:new Map};const r=(e,r,n)=>{const a=hook_default(t,o,r,e,n);return c&&s(),a},a=new Proxy(e,{apply:(e,t,o)=>r(t,o,!1),construct:(t,o)=>r(e,o,!0),get:(t,o,r)=>"toString"==o?e.toString.bind(e):Reflect.get(t,o,r)});Reflect.defineProperty(o,t,{value:a,configurable:!0,writable:!0})||(o[t]=a)}const a=Symbol(),s=()=>unpatch(o,t,a,e);return n[t][e].set(a,r),s},before=getPatchFunc_default("b"),instead=getPatchFunc_default("i"),after=getPatchFunc_default("a");
